## 启动流程

```
cmd/kube-apiserver/apiserver.go
main(): 程序入口
|
└─  cmd/kube-apiserver/app/server.go
    NewAPIServerCommand(): 解析命令行选项.
    |   创建`ServerRunOptions`对象, 设置默认值, 对传入的参数进行补全并验证
    |   
    ├─  cmd/kube-apiserver/app/options/options.go
    |   NewServerRunOptions(): 创建`ServerRunOptions`对象.
    |
    └─  cmd/kube-apiserver/app/server.go
        Run(): 使用传入的选项对象开始运行, 不会退出.
        |
        ├─  server = CreateServerChain(): 创建多个server(同时构造各server的配置对象)
        |   |   扩展server, 核心server, 聚合server, http server, 此函数之后还有https server.
        |   |   这里的server是聚合server `APIAggregator`对象.
        |   |
        |   ├─  CreateKubeAPIServerConfig(): 创建kubeAPIServerConfig配置
        |   |   |
        |   |   └─  buildGenericConfig(): 根据传入的 ServerRunOptions 参数, 构造 genericapiserver.Config 对象, 以及其他相关对象.
        |   |       |   
        |   |       └─  staging/src/k8s.io/apiserver/pkg/server/config.go
        |   |           NewConfig(): 使用默认值初始化 Config 对象并返回.
        |   |           |   BuildHandlerChainFunc 成员: 为 apiHandler 添加了很多默认的中间件(java中也有说叫filter过滤器), 有十几种.
        |   |           |   注意这里虽然为此成员字段赋值, 但并未执行.
        |   |
        |   |
        |   |
        |   ├─  CreateKubeAPIServer(): 创建核心server, 是一个Master{}对象, 同时会向其中挂载/,/swagger-ui等路由.
        |       | 
        |       ├─  kubeAPIServerConfig.Complete().New()
        |       |   |
        |       |   └─  pkg/master/master.go
        |               completedConfig.New() 根据已有的配置文件创建 Master{} 对象, 初始化其中的 GenericAPIServer 成员, 同时挂载内置路由.
        |               |   加载/api及/apis开头的路由(加载/api路由的方法叫作InstallLegacyAPI, 是因为这其中的资源很古老很核心, 所以叫Legacy).
        |               |
        |               ├─  staging/src/k8s.io/apiserver/pkg/server/config.go
        |               |   completedConfig.New(): 初始化apiServerHandler对象, 并赋值给 GenericAPIServer(返回对象).Handler 成员
        |               |   |   同时挂载了几条内置路由, 包括: /、/swagger-ui、/debug/*、/metrics、/version
        |               |   |   另外, 在挂载实际路由之前, 还通过调用 BuildHandlerChainFunc() 成员函数, 加载了十几种中间件, 包括RBAC, cors跨域及panic恢复等操作.
        |               |
        |               ├─  Master.InstallLegacyAPI(): 加载/api开头的路由, 提供资源访问入口
        |               |
        |               ├─  Master.InstallAPIs(): 加载/apis开头的路由, 提供资源访问入口
        |
        ├─  staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go
        |   prepared = server.PrepareRun(): 这里的prepared为`preparedAPIAggregator`对象
        |   说是准备工作, 不如说是启动前的路由收尾工作. 
        |   主要完成了Swagger和OpenAPI路由的注册工作(Swagger和OpenAPI主要包含了Kubernetes API的所有细节与规范), 
        |   并完成/healthz路由的注册工作.
        |
        |
        └─  staging/src/k8s.io/kube-aggregator/pkg/apiserver/apiserver.go
            preparedAPIAggregator.Run()
            |
            └─  preparedAPIAggregator.runnable.Run(): 这里的`runnable`为
                |   `preparedAPIAggregator.APIAggregator.GenericAPIServer.PrepareRun()`的返回值.
                |
                └─  staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go
                    |   preparedGenericAPIServer.Run(): 这里是核心 server 真正启动的地方. 
                    |   通过`NonBlockingRun()`启动安全的https server.
                    |   非安全方式的启动在`CreateServerChain()`中已经完成.
                    |
                    ├─  preparedGenericAPIServer.NonBlockingRun(): 
```

## RBAC流程

RBAC是在核心server启动前挂载中间件和路由handler的部分完成加载的, 在`staging/src/k8s.io/apiserver/pkg/server/config.go`中, 成员函数中`BuildHandlerChainFunc()`, 实际是被赋值了的`DefaultBuildHandlerChain()`函数.

```
staging/src/k8s.io/apiserver/pkg/server/config.go
DefaultBuildHandlerChain(): 为 apiHandler 挂载中间件
|
└─  staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go
    WithAuthorization():
    |
    ├─ GetAuthorizerAttributes(): 
    |
    ├─ 
```

## ETCD存储

```
pkg/master/master.go
Master.InstallLegacyAPI()
|
├─  pkg/registry/core/rest/storage_core.go
    LegacyRESTStorageProvider.NewLegacyRESTStorage():
    |
    |   podTemplateStorage, _ := podtemplatestore.NewREST()
    |   podStorage, _ := podstore.NewStorage()
    |   NewREST()与NewStorage()的区别在于, `REST`对象中包含着一个`Storage`对象...相当于对ta做了一层封装.
    |
```

## 请求流程

路由挂载过程

```
pkg/master/master.go
Master.New()
|
├─  Master.InstallLegacyAPI()
    |
    ├─  pkg/registry/core/rest/storage_core.go
    |   LegacyRESTStorageProvider.NewLegacyRESTStorage(): 创建`APIGroupInfo`对象
    |       APIGroupInfo.VersionedResourcesStorageMap["v1"]是各种资源(pod,node,event)的name与storage映射map
    |
    ├─  staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go
        GenericAPIServer.InstallLegacyAPIGroup(), 与 InstallAPIs(): 分别准备装载 /api, /apis 两个前缀下的路由
        |
        ├─  GenericAPIServer.installAPIResources(): 遍历 apiGroupInfo 下的 v1, betav1 等groupVersion,
            |   将ta们其下的各种资源name与storage映射, 加载到以apiPrefix为前缀的路由下.
            |
            ├─  staging/src/k8s.io/apiserver/pkg/endpoints/groupversion.go
                APIGroupVersion.InstallREST():
                |
                ├─  staging/src/k8s.io/apiserver/pkg/endpoints/installer.go
                |   APIInstaller.Install(): 遍历成员对象 group 中的 Storage, 重构成有序列表后依次注册到指定前缀下.
                |   |   返回的 WebService 对象, 有点像其他http框架中的 RouteGroup, 是一组 Route 对象的组合.
                |   |
                |   ├─  APIInstaller.registerResourceHandlers()
                |       |   registerResourceHandlers() 遍历目标资源(pod, pod/log等)支持的所有操作(get/list等), 
                |       |   将不同的操作注册为不同的路由(Create对应Post, Update对应Put等), 并与后端 Storage 的不同方法绑定.
                |       |   其中不同资源可执行的操作也不相同, 判断逻辑是, 各资源的Storage对象是否实现了 Getter, Lister 的接口,
                |       |   如果是, 则可以进行 get, list 操作.
                |       |   路由的 handler 部分在 staging/src/k8s.io/apiserver/pkg/endpoints/handlers/ 目录下, 
                |       |   有各种方法对应的源文件.
                |       |   但最终其实还是各种资源的 Storage 做了类型断言, 即ta们的 Storage 对象实现了 Get(), List() 方法.
                |       |   以 legacy 资源为例, ta们的 storage 构造函数都在 pkg/registry/core/{pod,node...}/storage/ 目录下,
                |       |   ta们的子资源也是.
                |       |
                |       ├─  restfulListResource(): 在`Watch/List/WatchList` 3个方法中有使用.
                |           |
                |           ├─  staging/src/k8s.io/apiserver/pkg/endpoints/handlers/get.go
                |               ListResource(): 
                |               |
                |               ├─  rest.Watcher.Watch(): 这里调用的是某一具体资源的 Storage 对象(如 PodStorage )的 
                |               |   Watcher 断言对象的 Watch() 方法, 返回一个 watcher 对象.
                |               |
                |               ├─  staging/src/k8s.io/apiserver/pkg/endpoints/handlers/watch.go
                |                   serveWatch(): 应该是在调用 ServeHTTP 前的一些准备工作, 超时判断, 序列化等.
                |                   |
                |                   ├─  WatchServer.ServeHTTP(): 把 WatchServer 中正在 Watching(Storage的watcher断言对象) 
                |                           的资源数据不断通过 http 的方式返回给客户端.
                |                           注意: watch 请求要么是通过http 1.1 的 trunk 连续返回数据, 要么是使用 ws 长连接.
                |
                ├─  container.Add(ws): 把`APIInstaller.Install()`生成的 WebService, 添加到Container中.
                |   |   go-restful 中的 Container 就类似其他web框架中的Server对象一样.
                |
```

在`pkg/registry/core/{pod,node...}/storage/`目录下, 你可能会发现很多资源的`Storage`对象连`Get`, `List`等方法都没有实现, 可能是因为ta们继承了`staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go`中的`Store`对象, 可以直接使用其中的通用方法.


## Cache

在挂载路由之前, `LegacyRESTStorageProvider.NewLegacyRESTStorage()`中生成各资源的 Storage 对象过程中, 就建立了与 etcd 的"数据库"连接, 同时构建了缓存.

而且应该是每种资源都单独建立了与 etcd 的连接, 并不是共用一个, 使用`netstat -anp | grep apiserver`会发现几十上百个与 etcd 集群的连接.

这样也使得每个 cacher 实例都是针对于单一资源类型的, 但是 Cacher 结构体及其方法是各资源通用的.

```
staging/src/k8s.io/apiserver/pkg/server/options/etcd.go
SimpleRestOptionsFactory.GetRESTOptions(), StorageFactoryRestOptionsFactory.GetRESTOptions()
|
├─  staging/src/k8s.io/apiserver/pkg/registry/generic/registry/storage_factory.go
    StorageWithCacher(): 返回`StorageDecorator`, 这其实是一个包装函数, 在
    |   staging/src/k8s.io/apiserver/pkg/registry/generic/registry/store.go
    |   中的 Store.CompleteWithOptions() 方法中初始化 `Store.Storage.Storage` 成员.
    |   注意: 此函数返回的是 cacher 对象, 其中封装着 storage 对象.
    |   
    ├─  staging/src/k8s.io/apiserver/pkg/registry/generic/storage_decorator.go
    |   NewRawStorage()
    |   |
    |   ├─  staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/factory.go
    |       Create(): 判断配置中是 etcd2 还是 etcd3, 初始化不同版本的客户端.
    |       |
    |       ├─  staging/src/k8s.io/apiserver/pkg/storage/storagebackend/factory/etcd3.go
    |           newETCD3Storage()
    |           |
    |           ├─  newETCD3Client(): 调用 etcd 官方库创建客户端对象.
    |           |
    |           ├─  staging/src/k8s.io/apiserver/pkg/storage/etcd3/store.go
    |               etcd3.New(): 根据上面创建的 etcd 客户端创建 store 对象, 
    |
    |
    |
    ├─  staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go
        NewCacherFromConfig(): 根据传入的配置创建 Cacher 对象, 此时 config 中包含已经创建好的 storage 对象.
        |
        |
        ├─  go cacher.dispatchEvents()
```

另外, cacher 主要用于 watch/list 缓存, 其余大部分操作都是通过其包含的 etcd storage 完成的.

各资源的 Watch 操作最终也是落在了 cacher 的 Watch 方法上. 

```
staging/src/k8s.io/apiserver/pkg/storage/cacher/cacher.go
Cacher.Watch():
|
├─  newCacheWatcher(): 创建一个 watcher 对象, 这个 watcher 与 PodStorage 的 Watcher 断言对象不同,
|       而是每次客户端发直 watch 请求, 都会生成一个 watcher( cacheWatcher 结构对象), 
|       这个 watcher 负责不断收集目标资源的数据, 之后由 http handler 中定义的处理函数返回给客户端.
|
├─  Cacher.watchers.addWatcher(): 把上面生成的 watcher 添加到 Cacher 对象的 watchers 成员 map 中.
|
├─  cacheWatcher.process() 对上面生成的 watcher 对象调用 process() 方法, 处理 cacheWatcher 本身的 input 通道中的事件.
    |   不过 input 通道
```

几个钩子函数(钩子函数通过`PostStartHooks()`注册):

1. 